// Code generated by bpf2go; DO NOT EDIT.

package xdp_gtp

import (
	"bytes"
	_ "embed"
	"fmt"
	"io"

	"github.com/cilium/ebpf"
)

type gtpClientInfo struct {
	Teid       uint32
	UpfIp      uint32
	EthNextHop [6]uint8
	EthLocal   [6]uint8
	Ifindex    uint32
}

type gtpUpfInfo struct {
	LocalIp    uint32
	EthNextHop [6]uint8
	EthLocal   [6]uint8
	Ifindex    uint32
}

type gtpUsageStats struct {
	Packets uint64
	Bytes   uint64
}

// loadGtp returns the embedded CollectionSpec for gtp.
func loadGtp() (*ebpf.CollectionSpec, error) {
	reader := bytes.NewReader(_GtpBytes)
	spec, err := ebpf.LoadCollectionSpecFromReader(reader)
	if err != nil {
		return nil, fmt.Errorf("can't load gtp: %w", err)
	}

	return spec, err
}

// loadGtpObjects loads gtp and converts it into a struct.
//
// The following types are suitable as obj argument:
//
//	*gtpObjects
//	*gtpPrograms
//	*gtpMaps
//
// See ebpf.CollectionSpec.LoadAndAssign documentation for details.
func loadGtpObjects(obj interface{}, opts *ebpf.CollectionOptions) error {
	spec, err := loadGtp()
	if err != nil {
		return err
	}

	return spec.LoadAndAssign(obj, opts)
}

// gtpSpecs contains maps and programs before they are loaded into the kernel.
//
// It can be passed ebpf.CollectionSpec.Assign.
type gtpSpecs struct {
	gtpProgramSpecs
	gtpMapSpecs
}

// gtpSpecs contains programs before they are loaded into the kernel.
//
// It can be passed ebpf.CollectionSpec.Assign.
type gtpProgramSpecs struct {
	XdpGtpClient *ebpf.ProgramSpec `ebpf:"xdp_gtp_client"`
	XdpGtpCommon *ebpf.ProgramSpec `ebpf:"xdp_gtp_common"`
	XdpGtpUpf    *ebpf.ProgramSpec `ebpf:"xdp_gtp_upf"`
}

// gtpMapSpecs contains maps before they are loaded into the kernel.
//
// It can be passed ebpf.CollectionSpec.Assign.
type gtpMapSpecs struct {
	ClientMap *ebpf.MapSpec `ebpf:"client_map"`
	Txcnt     *ebpf.MapSpec `ebpf:"txcnt"`
	UpfMap    *ebpf.MapSpec `ebpf:"upf_map"`
}

// gtpObjects contains all objects after they have been loaded into the kernel.
//
// It can be passed to loadGtpObjects or ebpf.CollectionSpec.LoadAndAssign.
type gtpObjects struct {
	gtpPrograms
	gtpMaps
}

func (o *gtpObjects) Close() error {
	return _GtpClose(
		&o.gtpPrograms,
		&o.gtpMaps,
	)
}

// gtpMaps contains all maps after they have been loaded into the kernel.
//
// It can be passed to loadGtpObjects or ebpf.CollectionSpec.LoadAndAssign.
type gtpMaps struct {
	ClientMap *ebpf.Map `ebpf:"client_map"`
	Txcnt     *ebpf.Map `ebpf:"txcnt"`
	UpfMap    *ebpf.Map `ebpf:"upf_map"`
}

func (m *gtpMaps) Close() error {
	return _GtpClose(
		m.ClientMap,
		m.Txcnt,
		m.UpfMap,
	)
}

// gtpPrograms contains all programs after they have been loaded into the kernel.
//
// It can be passed to loadGtpObjects or ebpf.CollectionSpec.LoadAndAssign.
type gtpPrograms struct {
	XdpGtpClient *ebpf.Program `ebpf:"xdp_gtp_client"`
	XdpGtpCommon *ebpf.Program `ebpf:"xdp_gtp_common"`
	XdpGtpUpf    *ebpf.Program `ebpf:"xdp_gtp_upf"`
}

func (p *gtpPrograms) Close() error {
	return _GtpClose(
		p.XdpGtpClient,
		p.XdpGtpCommon,
		p.XdpGtpUpf,
	)
}

func _GtpClose(closers ...io.Closer) error {
	for _, closer := range closers {
		if err := closer.Close(); err != nil {
			return err
		}
	}
	return nil
}

// Do not access this directly.
//
//go:embed gtp_bpf.o
var _GtpBytes []byte
